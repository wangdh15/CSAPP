##  Notes

### phase_1

通过阅读代码，发现其是读入一个字符串，然后比较这个字符串和一个固定位置的字符串是否相同。

然后通过`x /s <address>`指令就可以查看这个固定位置的字符串是多少，然后输入即可。

### phase_2

阅读`phase_2`函数的代码，会发现这个会将自己的`%rsp`减去24，传递给`read_six_number`。然后下面的代码会首先判断栈顶是否是1，然后再判断之后的数字是不是前一个数字的二倍。

所以直接输入`1 2 4 8 16 32`即可。

### phase_3

这部分主要是练习`switch`的跳转表的部分。

通过对`scanf`传入的参数字符串可知，读取了两个整数，然后根据第一个整数跳转到对应的位置，每个位置都会将`%eax`赋一个值，然后这个值需要和输入的第二个值相等，才能够通过。第一个数需要不超过7.

下面是输入的表，输入任何一组数据即可。

| 第一个数 | 第二个数 |
| :------: | :------: |
|    0     |   207    |
|    1     |   311    |
|    2     |   707    |
|    3     |   256    |
|    4     |   389    |
|    5     |   206    |
|    6     |   682    |
|    7     |   327    |

### phase_4

通过这道题目，学习了一些阅读汇编源码的技巧。

首先观察当前函数中，那些寄存器被改变了。将每个寄存器看做是一个变量。然后分辨出那些是全局变量，那些事局部变量。然后在按照汇编的逻辑，写成`C`语言的函数即可。

通过阅读`phase_4`的源码，发现`fun4`返回0，且第二个参数也是0的时候，会解锁。然后再通过阅读`phase_4`的代码，整理出逻辑，发现在一个分支，也就是输入的第一个参数为7的时候，就返回0.其余都是继续递归。所以可以直接输入`7 0`即可。

这个`fun4`的功能应该还有其他的方面，但是没有仔细研究。其他分支是一个递归函数。

### phase_5

这个阶段主要是考察数组的实现。通过输入长度为6的字符串，取出每个字符的后4为作为索引，然后查找一个固定的数组，最终需要拼出来的字符串是`flyers`。

答案不唯一，只要满足要求即可。`IONEFG`是一组解。

### phase_6

这一关比较复杂：

1. 首先读入六个数
2. 然后判断六个数是否都是不大于6的
3. 然后对每个数，用7减去它
4. 然后以这6个数进行遍历，得到6个地址
5. 然后将这六个地址前后串起来，得到一个链表。
6. 然后需要这个链表中的数字从前到后是单调递减的。

这一关需要详细查看`0x6032d0`开始的至少16个 long long 的内存的地址，然后仔细看代码，才能够搞清楚在干什么。

### 彩蛋关

TODO

